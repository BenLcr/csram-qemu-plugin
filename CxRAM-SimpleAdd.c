/* Begin Header autogenerated part */
/* Autogenerated C file */
/* Generation date / time : 2023-04-06 18:03:22.438311 */
#ifndef H2_TILE_CXRAM_H
#define H2_TILE_CXRAM_H
/* Autogenerated CXRAM configuration from ISA-2.0/csram-v2.0.5.json */
#include <stdint.h>
/* Vector len in bytes */
#define CXRAM_VECLEN (16)
/* Memory base address */
#define CXRAM_BASE_ADDR (0x10000000)
/* Memory line size in byte */
#define CXRAM_BASE_SIZE (8*1024)
/* Type definition */

typedef  union {
  int8_t            i8[CXRAM_VECLEN];
  int16_t           i16[CXRAM_VECLEN/2];
  int32_t           i32[CXRAM_VECLEN/4];
  int64_t           i64[CXRAM_VECLEN/8];
} h2_cxram_line_t;
typedef h2_cxram_line_t (*h2_cxram_array_t);
#define CXRAM_IMC_ADDR  0x80000000 /* Dummy storage to avoid seg fault during sw */
#define CXRAM_IMC_SIZE  0x04000000
/* Tile instance */
h2_cxram_array_t h2_cxram_tiles;
#endif
/* End of generated file h2-tile-cxram.h */#ifndef H2_COMMON
#define H2_COMMON

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdbool.h>
#ifdef H2SYS
#include <sys/mman.h>
#endif

bool h2_codeGenerationOK;

typedef struct
{
  int ValOrReg; // Boolean
  char arith;
  int vLen;
  int wLen;
  int regNro;
  int valueImm;
} h2_sValue_t;


enum ARCH_LIST {X86, RISCV, POWER,  K1,};
enum RISCV_VARIANT {RV32I,};
typedef enum {
    REGISTER,
    VALUE,
} VALORREG;

typedef union {
    float f;
    unsigned long i;
} h2_float_int_u;

#endif /*H2_COMMON*/
#ifndef H2_RISCV_CXRAM
#define H2_RISCV_CXRAM

#include <stdint.h>
#include <sys/mman.h>

typedef uint32_t     h2_insn_t;
static  h2_insn_t   *h2_asm_pc;
static  h2_insn_t   *h2_save_asm_pc;


void fatalError (char * msg)
{
  fprintf(stderr, "%s\n", msg);
  exit(-1);
}
static void h2_init_cxram ()
{
  h2_cxram_line_t *base_addr, *cxram_imc;
  int prot, flags;

#if 0
  /* Tiles allocations */
  if (h2_cxram_tiles == NULL)
	h2_cxram_tiles = (h2_cxram_line_t *)calloc(CXRAM_BASE_SIZE, sizeof (char));
#endif

  /* mmap properties */
  prot =  PROT_READ  | PROT_WRITE    | PROT_EXEC;
  flags = MAP_SHARED | MAP_ANONYMOUS | MAP_FIXED;
  /* Tiles mapping at a fixed address */
  base_addr = (h2_cxram_line_t *)mmap((void *)CXRAM_BASE_ADDR, (CXRAM_BASE_SIZE), prot, flags, 0, 0);
  if(base_addr != (void*)((uintptr_t)CXRAM_BASE_ADDR))
	fatalError("Failed mmap for TILES\n");
  /* Mapping to avoid core dump during store word instructions */
  cxram_imc = (h2_cxram_line_t *)mmap((void *)CXRAM_IMC_ADDR,   (CXRAM_IMC_SIZE), prot, flags, 0, 0);
  if(cxram_imc != (void*)((uintptr_t)CXRAM_IMC_ADDR))
	fatalError("Failed mmap for \n");

#ifdef H2_DEBUG
  printf("Init CxRAM %p mapped at %p for %d bytes\n", CXRAM_BASE_ADDR, base_addr, CXRAM_BASE_SIZE);
#endif
  //  if (h2_cxram_tiles == NULL)
  h2_cxram_tiles = base_addr;
}

static void h2_iflush(void *addr, void *last)
{
#ifdef H2SYS
	long pageSize= getpagesize();
	void *ptmp= (char *)((long)addr & ~(pageSize - 1));
	if (mprotect(ptmp, (last - addr), PROT_READ | PROT_WRITE | PROT_EXEC))
	  fatalError("iflush: mprotect");
#ifdef H2_DEBUG
	printf("Flush data cache from %p to %p\n", addr, last);
#endif
#endif
	if (!h2_codeGenerationOK)
	{
		fprintf (stderr, "(iflush) Failed code generation\n");
		exit(-5);
	}
}

static h2_insn_t *h2_malloc (size_t size)
{
	return malloc (size);
}

#endif /*H2_RISCV_CXRAM*/

#define riscv_G32(INSN){ *(h2_asm_pc++) = (INSN);}

#define RV32I_RET__I_32_1() /* RET */ \
do { \
	riscv_G32(((0x8067 >> 0) & 0xffffffff)); \
} while(0)

#define RV32I_ANDI_RRI_I_32_1(r3,r1,i1) /* AND */ \
do { \
	riscv_G32(((i1 & 0xfff) << 20)|((r1 & 0x1f) << 15)|((0x7 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x13 & 0x7f) >> 0)); \
} while(0)

#define RV32I_AND_RRR_I_32_1(r3,r1,r2) /* AND */ \
do { \
	riscv_G32(((0x0 & 0x7f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x7 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x33 & 0x7f) >> 0)); \
} while(0)

#define RV32I_LUI_RI_I_32_1(r3,i1) /* LUI */ \
do { \
	riscv_G32(((i1 & 0xfffff) << 12)|((r3 & 0x1f) << 7)|((0x37 & 0x7f) >> 0)); \
} while(0)

#define RV32I_MV_RR_I_32_1(r0,r1) /* MV */ \
do { \
	riscv_G32(((0x0 & 0xfff) << 20)|((r1 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((r0 & 0x1f) << 7)|((0x13 & 0x7f) >> 0)); \
} while(0)

#define RV32I_MV_RI_I_32_1(r3,i1) /* MV */ \
do { \
	riscv_G32(((i1 & 0xfff) << 20)|((0x6 & 0xff) << 12)|((r3 & 0x1f) << 7)|((0x13 & 0x7f) >> 0)); \
} while(0)

#define RV32I_ORI_RRI_I_32_1(r3,r1,i1) /* OR */ \
do { \
	riscv_G32(((i1 & 0xfff) << 20)|((r1 & 0x1f) << 15)|((0x6 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x13 & 0x7f) >> 0)); \
} while(0)

#define RV32I_OR_RRR_I_32_1(r3,r1,r2) /* OR */ \
do { \
	riscv_G32(((0x0 & 0x7f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x6 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x33 & 0x7f) >> 0)); \
} while(0)

#define RV32I_SRLI_RRI_I_32_1(r3,r1,i0) /* SR */ \
do { \
	riscv_G32(((0x0 & 0x7f) << 25)|((i0 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x5 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x13 & 0x7f) >> 0)); \
} while(0)

#define RV32I_SRL_RRR_I_32_1(r3,r1,r2) /* SR */ \
do { \
	riscv_G32(((0x0 & 0x7f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x5 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x33 & 0x7f) >> 0)); \
} while(0)

#define RV32I_SB_RRI_I_8_1(r1,r2,i1) /* W */ \
do { \
	riscv_G32((((i1 >> 5) & 0x7f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((i1 & 0x1f) << 7)|((0x23 & 0x7f) >> 0)); \
} while(0)

#define RV32I_SH_RRI_I_16_1(r1,r2,i1) /* W */ \
do { \
	riscv_G32((((i1 >> 5) & 0x7f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x1 & 0x7) << 12)|((i1 & 0x1f) << 7)|((0x23 & 0x7f) >> 0)); \
} while(0)

#define RV32I_SW_RRI_I_32_1(r1,r2,i1) /* W */ \
do { \
	riscv_G32((((i1 >> 5) & 0x7f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x2 & 0x7) << 12)|((i1 & 0x1f) << 7)|((0x23 & 0x7f) >> 0)); \
} while(0)

#define RV32I_SLLI_RRI_I_32_1(r3,r1,i0) /* SL */ \
do { \
	riscv_G32(((0x0 & 0x7f) << 25)|((i0 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x1 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x13 & 0x7f) >> 0)); \
} while(0)

#define RV32I_SLL_RRR_I_32_1(r3,r1,r2) /* SL */ \
do { \
	riscv_G32(((0x0 & 0x7f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x1 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x33 & 0x7f) >> 0)); \
} while(0)

#define RV32I_ADDI_RRI_I_32_1(r1,r0,i0) /* ADD */ \
do { \
	riscv_G32(((i0 & 0xfff) << 20)|((r0 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((r1 & 0x1f) << 7)|((0x13 & 0x7f) >> 0)); \
} while(0)

#define RV32I_ADD_RRR_I_32_1(r3,r1,r2) /* ADD */ \
do { \
	riscv_G32(((0x0 & 0x7f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x33 & 0x7f) >> 0)); \
} while(0)
void riscv_genAND_3(h2_sValue_t P0, h2_sValue_t P1, h2_sValue_t P2)
{

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
        RV32I_ANDI_RRI_I_32_1(P0.regNro, P1.regNro, P2.valueImm);
    }

    else if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        RV32I_AND_RRR_I_32_1(P0.regNro, P1.regNro, P2.regNro);
    }

    else
    {
        printf("Warning, generation of AND is not possible with this arguments P0: %c, %i, %i,  P0: %i , P1: %i , P2: %i \n", P0.arith, P0.wLen, P0.vLen, P0.ValOrReg ,P1.ValOrReg ,P2.ValOrReg);
        h2_codeGenerationOK = false;
    }
}
void riscv_genLUI_2(h2_sValue_t P0, h2_sValue_t P1)
{

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == VALUE)
    {
        RV32I_LUI_RI_I_32_1(P0.regNro, P1.valueImm);
    }

    else
    {
        printf("Warning, generation of LUI is not possible with this arguments P0: %c, %i, %i,  P0: %i , P1: %i \n", P0.arith, P0.wLen, P0.vLen, P0.ValOrReg ,P1.ValOrReg);
        h2_codeGenerationOK = false;
    }
}
void riscv_genMV_2(h2_sValue_t P0, h2_sValue_t P1)
{

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER)
    {
        RV32I_MV_RR_I_32_1(P0.regNro, P1.regNro);
    }

    else if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == VALUE)
    {
        RV32I_MV_RI_I_32_1(P0.regNro, P1.valueImm);
    }

    else
    {
        printf("Warning, generation of MV is not possible with this arguments P0: %c, %i, %i,  P0: %i , P1: %i \n", P0.arith, P0.wLen, P0.vLen, P0.ValOrReg ,P1.ValOrReg);
        h2_codeGenerationOK = false;
    }
}
void riscv_genOR_3(h2_sValue_t P0, h2_sValue_t P1, h2_sValue_t P2)
{

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
        RV32I_ORI_RRI_I_32_1(P0.regNro, P1.regNro, P2.valueImm);
    }

    else if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        RV32I_OR_RRR_I_32_1(P0.regNro, P1.regNro, P2.regNro);
    }

    else
    {
        printf("Warning, generation of OR is not possible with this arguments P0: %c, %i, %i,  P0: %i , P1: %i , P2: %i \n", P0.arith, P0.wLen, P0.vLen, P0.ValOrReg ,P1.ValOrReg ,P2.ValOrReg);
        h2_codeGenerationOK = false;
    }
}
void riscv_genSR_3(h2_sValue_t P0, h2_sValue_t P1, h2_sValue_t P2)
{

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
        RV32I_SRLI_RRI_I_32_1(P0.regNro, P1.regNro, P2.valueImm);
    }

    else if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        RV32I_SRL_RRR_I_32_1(P0.regNro, P1.regNro, P2.regNro);
    }

    else
    {
        printf("Warning, generation of SR is not possible with this arguments P0: %c, %i, %i,  P0: %i , P1: %i , P2: %i \n", P0.arith, P0.wLen, P0.vLen, P0.ValOrReg ,P1.ValOrReg ,P2.ValOrReg);
        h2_codeGenerationOK = false;
    }
}
void riscv_genRET_0()
{

    RV32I_RET__I_32_1();

}
void riscv_genW_3(h2_sValue_t P0, h2_sValue_t P1, h2_sValue_t P2)
{

    if ((P1.arith == 'i') && (P1.wLen <= 8) && (P1.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
        RV32I_SB_RRI_I_8_1(P0.regNro, P1.regNro, P2.valueImm);
    }

    else if ((P1.arith == 'i') && (P1.wLen <= 16) && (P1.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
        RV32I_SH_RRI_I_16_1(P0.regNro, P1.regNro, P2.valueImm);
    }

    else if ((P1.arith == 'i') && (P1.wLen <= 32) && (P1.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
        RV32I_SW_RRI_I_32_1(P0.regNro, P1.regNro, P2.valueImm);
    }

    else
    {
        printf("Warning, generation of W is not possible with this arguments P0: %c, %i, %i,  P0: %i , P1: %i , P2: %i \n", P0.arith, P0.wLen, P0.vLen, P0.ValOrReg ,P1.ValOrReg ,P2.ValOrReg);
        h2_codeGenerationOK = false;
    }
}
void riscv_genSL_3(h2_sValue_t P0, h2_sValue_t P1, h2_sValue_t P2)
{

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
        RV32I_SLLI_RRI_I_32_1(P0.regNro, P1.regNro, P2.valueImm);
    }

    else if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        RV32I_SLL_RRR_I_32_1(P0.regNro, P1.regNro, P2.regNro);
    }

    else
    {
        printf("Warning, generation of SL is not possible with this arguments P0: %c, %i, %i,  P0: %i , P1: %i , P2: %i \n", P0.arith, P0.wLen, P0.vLen, P0.ValOrReg ,P1.ValOrReg ,P2.ValOrReg);
        h2_codeGenerationOK = false;
    }
}
void riscv_genADD_3(h2_sValue_t P0, h2_sValue_t P1, h2_sValue_t P2)
{

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
        RV32I_ADDI_RRI_I_32_1(P0.regNro, P1.regNro, P2.valueImm);
    }

    else if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        RV32I_ADD_RRR_I_32_1(P0.regNro, P1.regNro, P2.regNro);
    }

    else
    {
        printf("Warning, generation of ADD is not possible with this arguments P0: %c, %i, %i,  P0: %i , P1: %i , P2: %i \n", P0.arith, P0.wLen, P0.vLen, P0.ValOrReg ,P1.ValOrReg ,P2.ValOrReg);
        h2_codeGenerationOK = false;
    }
}

/* End Header autogenerated part */
// -*- c -*-

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

typedef  void (*pifiii)(h2_cxram_line_t *, h2_cxram_line_t*, h2_cxram_line_t*);

pifiii genSimpleAdd8(h2_insn_t * ptr)
{
/* Code Generation of 32 instructions */
/* Symbol table :*/
	/*VarName = { ValOrLen, arith, vectorLen, wordLen, regNo, Value} */
	h2_sValue_t a = {REGISTER, 'i', 1, 32, 10, 0};
	h2_sValue_t b = {REGISTER, 'i', 1, 32, 11, 0};
	h2_sValue_t res = {REGISTER, 'i', 1, 32, 12, 0};
	h2_sValue_t h2_outputVarName = {REGISTER, 'i', 16, 8, 10, 0};
	h2_sValue_t h2_00000009 = {REGISTER, 'i', 1, 32, 5, 0};
	h2_sValue_t h2_00000010 = {REGISTER, 'i', 1, 32, 5, 0};
	h2_sValue_t h2_00000012 = {REGISTER, 'i', 1, 32, 5, 0};
	h2_sValue_t h2_00000013 = {REGISTER, 'i', 1, 32, 5, 0};
	h2_sValue_t h2_00000022 = {REGISTER, 'i', 1, 32, 5, 0};
	h2_sValue_t h2_00000023 = {REGISTER, 'i', 1, 32, 5, 0};
	h2_sValue_t h2_00000025 = {REGISTER, 'i', 1, 32, 5, 0};
	h2_sValue_t h2_00000026 = {REGISTER, 'i', 1, 32, 5, 0};
	h2_sValue_t h2_00000035 = {REGISTER, 'i', 1, 32, 5, 0};
	h2_sValue_t h2_00000036 = {REGISTER, 'i', 1, 32, 5, 0};
	h2_sValue_t h2_00000038 = {REGISTER, 'i', 1, 32, 5, 0};
	h2_sValue_t h2_00000039 = {REGISTER, 'i', 1, 32, 5, 0};
	h2_sValue_t h2_00000042 = {REGISTER, 'i', 1, 32, 5, 0};
	h2_sValue_t h2_00000051 = {REGISTER, 'i', 1, 32, 5, 0};
	h2_sValue_t h2_00000011 = {REGISTER, 'i', 1, 32, 6, 0};
	h2_sValue_t h2_00000024 = {REGISTER, 'i', 1, 32, 6, 0};
	h2_sValue_t h2_00000037 = {REGISTER, 'i', 1, 32, 6, 0};
	h2_sValue_t h2_00000046 = {REGISTER, 'i', 1, 32, 6, 0};
	h2_sValue_t h2_00000047 = {REGISTER, 'i', 1, 32, 6, 0};
	h2_sValue_t h2_00000055 = {REGISTER, 'i', 1, 32, 7, 0};
	h2_sValue_t h2_00000056 = {REGISTER, 'i', 1, 32, 7, 0};


/* Label  table :*/
#define riscv_genLABEL(LABEL_ID) labelAddresses[LABEL_ID] = h2_asm_pc;
h2_insn_t   * labelAddresses []={
	0, /* h2_csram_00000000 */
	#define h2_csram_00000000 0
	};


	h2_asm_pc = (h2_insn_t *) ptr;
	h2_codeGenerationOK = true;
	riscv_genLABEL(h2_csram_00000000);
	riscv_genMV_2(h2_00000009, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, 4095});
	riscv_genSL_3(h2_00000010, h2_00000009, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, 20});
	riscv_genSR_3(h2_00000011, h2_00000010, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, 20});
	riscv_genLUI_2(h2_00000012, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, 15});
	riscv_genOR_3(h2_00000012, h2_00000011, h2_00000012);
	riscv_genAND_3(h2_00000012, res, h2_00000012);
	riscv_genSR_3(res, h2_00000012, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, 4});
	riscv_genMV_2(h2_00000022, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, 4095});
	riscv_genSL_3(h2_00000023, h2_00000022, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, 20});
	riscv_genSR_3(h2_00000024, h2_00000023, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, 20});
	riscv_genLUI_2(h2_00000025, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, 15});
	riscv_genOR_3(h2_00000025, h2_00000024, h2_00000025);
	riscv_genAND_3(h2_00000025, b, h2_00000025);
	riscv_genSR_3(b, h2_00000025, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, 4});
	riscv_genMV_2(h2_00000035, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, 4095});
	riscv_genSL_3(h2_00000036, h2_00000035, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, 20});
	riscv_genSR_3(h2_00000037, h2_00000036, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, 20});
	riscv_genLUI_2(h2_00000038, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, 15});
	riscv_genOR_3(h2_00000038, h2_00000037, h2_00000038);
	riscv_genAND_3(h2_00000038, a, h2_00000038);
	riscv_genSR_3(a, h2_00000038, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, 4});
	riscv_genLUI_2(h2_00000042, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, 527872});
	riscv_genADD_3(h2_00000046, res, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, 0});
	riscv_genSL_3(h2_00000047, h2_00000046, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, 2});
	riscv_genOR_3(h2_00000047, h2_00000042, h2_00000047);
	riscv_genADD_3(h2_00000051, a, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, 0});
	riscv_genADD_3(h2_00000055, b, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, 0});
	riscv_genSL_3(h2_00000056, h2_00000055, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, 16});
	riscv_genOR_3(h2_00000056, h2_00000051, h2_00000056);
	riscv_genW_3(h2_00000047, h2_00000056, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (int)(0)});
	riscv_genRET_0();
	/* Call back code for loops */
	h2_save_asm_pc = h2_asm_pc;
	h2_asm_pc = h2_save_asm_pc;
	h2_iflush(ptr, h2_asm_pc);

	return (pifiii) ptr;
}
void printVec(h2_cxram_line_t * vectorLine, int len, char * mesg)
{
  int i;
  printf ("%s", mesg);
  for (i=0; i < len; i++)
	{
	  printf("  %03d", vectorLine->i8[i]);
	}
  printf ("\n");
}


int main(int argc, char * argv[])
{
  int i, resultOK;
	h2_insn_t * ptr;
	pifiii code;
	h2_cxram_line_t *in1, *in2, *res;

	h2_init_cxram ();
	in1 = &h2_cxram_tiles[0];
	in2 = &h2_cxram_tiles[1];
    res = &h2_cxram_tiles[2];
	if (argc < (CXRAM_VECLEN  + 1))
	{
	  printf("Not enough arguments (%d)\n", argc);
	  exit(-1);
	}
	for (i=0; i < CXRAM_VECLEN; i++)
	{
	  in1->i8[i] = atoi(argv[i+1]);
	  in2->i8[i] = 42;
	  res->i8[i] = 0;
	}
	ptr = h2_malloc (1024);
	code = genSimpleAdd8(ptr);
	code (in1, in2, res);
	printVec (in1, CXRAM_VECLEN, " ");
	printVec (in2, CXRAM_VECLEN, "+");
	printVec (res, CXRAM_VECLEN, "=");
	resultOK = 0;
	for (i=0; i < CXRAM_VECLEN / sizeof(in1[0]); i++)
	  {
		if (res->i8[i] != (in1->i8[i] + in2->i8[i]))
		  resultOK = 1;
	  }
	return resultOK;
}
